import numpy as np
import pandas as pd
import os

# 预计算的原子索引
中心原子索引 = 37  # 单空位和双空位结构中均需移除的原子
第二个空位原子索引 = 12  # 双空位结构中额外需要移除的原子

# 配位位点（用于原子替换）
单空位配位位点 = [12, 13, 18]  # 已排序，用于单空位结构的原子分配
双空位配位位点 = [13, 18, 31, 36]  # 已排序，用于无双空位后缀结构的原子分配

# 变体结构的原子对
变体结构原子对 = {
    '-opp': [13, 36],
    '-pen': [13, 31],
    '-hex': [31, 36]
}

# 晶胞矩阵
gamma角度弧度 = 120 * np.pi / 180
晶胞向量A = np.array([12.336457, 0, 0])
晶胞向量B = np.array([12.336457 * np.cos(gamma角度弧度), 12.336457 * np.sin(gamma角度弧度), 0])
晶胞向量C = np.array([0, 0, 5.0])
晶胞矩阵 = np.array([晶胞向量A, 晶胞向量B, 晶胞向量C])

# 分数坐标列表（5 * 5）
原子分数坐标列表 = []
# 第一组原子坐标（x步长0.2，y步长0.2）
for i in range(5):
    for j in range(5):
        原子分数坐标列表.append(np.array([i * 0.2, j * 0.2, 0.25]))
# 第二组原子坐标（x起始0.066667、步长0.2，y起始0.133333、步长0.2）
for i in range(5):
    for j in range(5):
        原子分数坐标列表.append(np.array([0.066667 + i * 0.2, 0.133333 + j * 0.2, 0.25]))

# 解析结构字符串的函数（从结构表达式中提取金属、元素计数、变体后缀、空位类型）
def 解析结构字符串(结构字符串):
    # 分割金属元素和配位元素部分
    金属元素, 剩余部分 = 结构字符串.split('_')
    变体后缀 = None
    # 检查是否包含变体后缀（格式如"Fe_C2N1-opp"）
    if '-' in 剩余部分:
        剩余部分, 临时后缀 = 剩余部分.rsplit('-', 1)
        变体后缀 = '-' + 临时后缀
    
    # 统计各元素的数量（如"C2N1"解析为{'C':2, 'N':1}）
    元素计数字典 = {}
    索引 = 0
    while 索引 < len(剩余部分):
        # 提取元素符号（单个大写字母，后续可能跟小写字母，此处简化处理单字母元素）
        元素符号 = 剩余部分[索引]
        索引 += 1
        # 提取元素数量（默认1，若后续为数字则读取数字）
        元素数量 = 1
        if 索引 < len(剩余部分) and 剩余部分[索引].isdigit():
            元素数量 = int(剩余部分[索引])
            索引 += 1
        # 更新元素计数字典
        元素计数字典[元素符号] = 元素计数字典.get(元素符号, 0) + 元素数量
    
    # 判断是否为双空位结构（配位元素总数为4时为双空位）
    总元素数量 = sum(元素计数字典.values())
    是否双空位 = 总元素数量 == 4
    
    return 金属元素, 元素计数字典, 变体后缀, 是否双空位

# 获取元素多重列表的函数（将元素计数转换为有序列表，如{'C':2, 'N':1}→['C','C','N']）
def 获取元素多重列表(元素计数字典):
    元素多重列表 = []
    # 按元素符号排序后，根据计数重复添加元素
    for 元素符号 in sorted(元素计数字典):
        元素多重列表 += [元素符号] * 元素计数字典[元素符号]
    return 元素多重列表

# 生成XYZ文件的函数
def 生成XYZ文件(结构字符串):
    # 解析结构字符串获取关键参数
    金属元素, 元素计数字典, 变体后缀, 是否双空位 = 解析结构字符串(结构字符串)
    需要移除的原子索引 = [中心原子索引]
    配位位点列表 = 单空位配位位点 if not 是否双空位 else 双空位配位位点
    if 是否双空位:
        需要移除的原子索引.append(第二个空位原子索引)

    位点元素分配字典 = {}
    if 是否双空位 and 变体后缀:
        重复元素 = None
        for 元素符号 in ['C', 'B', 'N', 'O', 'P', 'S']:
            if 元素计数字典.get(元素符号, 0) == 2:
                重复元素 = 元素符号
                break
        if 重复元素:
            变体原子对 = 变体结构原子对[变体后缀]
            for 位点索引 in 变体原子对:
                位点元素分配字典[位点索引] = 重复元素
            剩余元素计数字典 = 元素计数字典.copy()
            剩余元素计数字典[重复元素] -= 2
            剩余元素多重列表 = 获取元素多重列表(剩余元素计数字典)
            剩余位点列表 = sorted(set(双空位配位位点) - set(变体原子对))
            for 索引, 位点索引 in enumerate(剩余位点列表):
                位点元素分配字典[位点索引] = 剩余元素多重列表[索引]
        else:
            元素多重列表 = 获取元素多重列表(元素计数字典)
            排序后的配位位点 = sorted(双空位配位位点)
            for 索引, 位点索引 in enumerate(排序后的配位位点):
                位点元素分配字典[位点索引] = 元素多重列表[索引]
    else:
        元素多重列表 = 获取元素多重列表(元素计数字典)
        排序后的配位位点 = sorted(配位位点列表)
        for 索引, 位点索引 in enumerate(排序后的配位位点):
            位点元素分配字典[位点索引] = 元素多重列表[索引]

    # 计算金属原子的分数坐标（取移除原子坐标的平均值）
    移除原子的分数坐标 = [原子分数坐标列表[索引] for 索引 in 需要移除的原子索引]
    金属原子分数坐标 = np.mean(移除原子的分数坐标, axis=0)
    if len(需要移除的原子索引) == 1:
        # 单空位
        金属原子分数坐标[2] = 0.25
    else:
        # 双空位
        金属原子分数坐标[2] = 0.25 

    # 晶胞参数
    晶胞向量A = np.array([12.336457, 0, 0])
    gamma角度弧度 = 120 * np.pi / 180
    晶胞向量B = np.array([12.336457 * np.cos(gamma角度弧度), 12.336457 * np.sin(gamma角度弧度), 0])
    晶胞向量C = np.array([0, 0, 15.0])

    # 分数坐标转笛卡尔坐标
    def frac2cart(frac):
        return frac[0] * 晶胞向量A + frac[1] * 晶胞向量B + frac[2] * 晶胞向量C

    xyz_atoms = []
    原子计数 = 0
    for frac in 原子分数坐标列表:
        if 原子计数 in 需要移除的原子索引:
            原子计数 += 1
            continue
        元素 = "C"
        if 原子计数 in 位点元素分配字典:
            元素 = 位点元素分配字典[原子计数]
        cart = frac2cart(frac)
        xyz_atoms.append((元素, cart))
        原子计数 += 1

    # 添加金属原子
    金属_cart = frac2cart(金属原子分数坐标)
    xyz_atoms.append((金属元素, 金属_cart))

    # 写入xyz文件
    xyz保存目录 = "xyzs"
    os.makedirs(xyz保存目录, exist_ok=True)
    输出文件路径 = os.path.join(xyz保存目录, f"{结构字符串}.xyz")
    with open(输出文件路径, 'w', encoding='utf-8') as f:
        f.write(f"{len(xyz_atoms)}\n")
        f.write(f"{结构字符串}\n")
        for 元素, 坐标 in xyz_atoms:
            f.write(f"{元素} {坐标[0]:.6f} {坐标[1]:.6f} {坐标[2]:.6f}\n")
    print(f"已生成XYZ文件：{输出文件路径}")

# 主程序：读取CSV文件并批量生成文件
if __name__ == "__main__":
    # 读取包含结构字符串的CSV文件
    结构数据框 = pd.read_csv('数据集.csv')
    
    # 遍历所有结构字符串，逐个生成文件
    for 结构字符串 in 结构数据框['structure']:
        生成XYZ文件(结构字符串)